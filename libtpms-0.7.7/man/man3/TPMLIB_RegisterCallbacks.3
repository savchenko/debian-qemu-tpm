.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TPMLIB_RegisterCallbacks 3"
.TH TPMLIB_RegisterCallbacks 3 "2019-03-26" "libtpms" ""
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TPMLIB_RegisterCallbacks    \- Register callbacks for implementing customized
behavior of certain functions
.SH "LIBRARY"
.IX Header "LIBRARY"
\&\s-1TPM\s0 library (libtpms, \-ltpms)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fB#include <libtpms/tpm_types.h\fR>
.PP
\&\fB#include <libtpms/tpm_library.h\fR>
.PP
\&\fB#include <libtpms/tpm_error.h\fR>
.PP
\&\fB\s-1TPM_RESULT\s0 TPMLIB_RegisterCallbacks(struct tpmlibrary_callbacks *);\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fB\fBTPMLIB_RegisterCallbacks()\fB\fR functions allows to register several
callback functions with libtpms that enable a user to implement customized
behavior of several library-internal functions. This feature will typically
be used if the behavior of the provided internal functions is not as needed.
An example would be that libtpms writes all data into files with certain names.
If, however, the data needs to be written into a special type of storage
the user will register callbacks with the library that are invoked when
the \s-1TPM\s0 needs to write, read or delete data from storage and the user may
then implement custom behavior in these functions.
.PP
The following shows the data structure used for registering the callbacks.
.PP
.Vb 10
\&    struct libtpms_callbacks {  
\&            int sizeOfStruct;
\&            TPM_RESULT (*tpm_nvram_init)(void);
\&            TPM_RESULT (*tpm_nvram_loaddata)(unsigned char **data,
\&                                             uint32_t *length,
\&                                             uint32_t tpm_number,
\&                                             const char *name);
\&            TPM_RESULT (*tpm_nvram_storedata)(const unsigned char *data,
\&                                              uint32_t length,
\&                                              uint32_t tpm_number,
\&                                              const char *name);
\&            TPM_RESULT (*tpm_nvram_deletename)(uint32_t tpm_number,
\&                                               const char *name,
\&                                               TPM_BOOL mustExist);
\&            TPM_RESULT (*tpm_io_init)(void);
\&            TPM_RESULT (*tpm_io_getlocality)(TPM_MODIFIER_INDICATOR *localityModifer,
\&                                             uint32_t tpm_number);
\&            TPM_RESULT (*tpm_io_getphysicalpresence)(TPM_BOOL *physicalPresence,
\&                                                     uint32_t tpm_number);
\&    };
.Ve
.PP
Currently 7 callbacks are supported. If a callback pointer in the above
structure is set to \s-1NULL\s0 the default library-internal implementation
of that function will be used.
.PP
If one of the callbacks in either the \fItpm_nvram\fR or \fItpm_io\fR group is
set, then all of the callbacks in the respective group should
be implemented.
.IP "\fBtpm_nvram_init\fR" 4
.IX Item "tpm_nvram_init"
This function is called before any access to persitent storage is done. It
allows the user to perform initialization of access to persitent storage.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation requires that the environment variable
\&\fI\s-1TPM_PATH\s0\fR is set and points to a directory where the \s-1TPM\s0's state
can be written to. If the variable is not set, it will return \fB\s-1TPM_FAIL\s0\fR
and the initialization of the \s-1TPM\s0 in \fB\fBTPMLIB_MainInit()\fB\fR will fail.
.IP "\fBtpm_nvram_loaddata\fR" 4
.IX Item "tpm_nvram_loaddata"
This function is called when the \s-1TPM\s0 wants to load state from persistent
storage. The implementing function must allocate a buffer (\fIdata\fR)
and return it to the \s-1TPM\s0 along with the length of the buffer (\fIlength\fR).
The \fItpm_number\fR is always 0 and can be ignored. 
The \fIname\fR parameter is either one of \fB\s-1TPM_SAVESTATE_NAME\s0\fR,
\&\fB\s-1TPM_VOLATILESTATE_NAME\s0\fR, or \fB\s-1TPM_PERMANENT_ALL_NAME\s0\fR and indicates
which one of the 3 types of state is supposed to be loaded.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation writes the \s-1TPM\s0's state into files in a directory
where the \fI\s-1TPM_PATH\s0\fR environment variable pointed to when
\&\fB\fBTPMLIB_MainInit()\fB\fR was executed. Failure to write the \s-1TPM\s0's state into
files will put the \s-1TPM\s0 into failure mode.
.Sp
If this function is not set (\s-1NULL\s0), then the original NVChip file
will be read when using a \s-1TPM 2.\s0 This file contains the memory dump of
internal data structures and is neither portable between endianesses or
architectures of different sizes (32 bit, 64 bit), nor will it allow
handling extensions of those internal data structures it carries
through additions in the \s-1TPM 2\s0 code. In the worst case this may result
in memory access errors by internal functions and result in crashes.
Therefore, it is recommended to set this function and handle the writing
of the \s-1TPM\s0 state.
.IP "\fBtpm_nvram_storedata\fR" 4
.IX Item "tpm_nvram_storedata"
This function is called when the \s-1TPM\s0 wants to store state to persistent
storage. The \fIdata\fR and \fIlength\fR parameters provide the data to be
stored and the number of bytes. The implementing function must not
free the \fIdata\fR buffer.
The \fItpm_number\fR is always 0 and can be ignored. 
The \fIname\fR parameter is either one of \fB\s-1TPM_SAVESTATE_NAME\s0\fR,
\&\fB\s-1TPM_VOLATILESTATE_NAME\s0\fR, or \fB\s-1TPM_PERMANENT_ALL_NAME\s0\fR and indicates
which one of the 3 types of state is supposed to be stored.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation reads the \s-1TPM\s0's state from files in a directory
where the \fI\s-1TPM_PATH\s0\fR environment variable pointed to when
\&\fB\fBTPMLIB_MainInit()\fB\fR was executed. Failure to read the \s-1TPM\s0's state from
files may put the \s-1TPM\s0 into failure mode.
.Sp
If this function is not set (\s-1NULL\s0), the memory dump will be written
to the NVChip file (\s-1TPM 2\s0) and the same comments apply as when the
\&\fItpm_nvram_loaddata\fR interface function is not set.
.IP "\fBtpm_nvram_deletename\fR" 4
.IX Item "tpm_nvram_deletename"
This function is called when the \s-1TPM\s0 wants to delete state on persistent
storage. 
The \fItpm_number\fR is always 0 and can be ignored. 
The \fIname\fR parameter is either one of \fB\s-1TPM_SAVESTATE_NAME\s0\fR,
\&\fB\s-1TPM_VOLATILESTATE_NAME\s0\fR, or \fB\s-1TPM_PERMANENT_ALL_NAME\s0\fR and indicates
which one of the 3 types of state is supposed to be deleted.
The \fImustExist\fR parameter indicates wheteher the given data must exist
and the implementing function should return \fB\s-1TPM_FAIL\s0\fR if the data did
not exist.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation deletes the \s-1TPM\s0's state files in a directory
where the \fI\s-1TPM_PATH\s0\fR environment variable pointed to when
\&\fB\fBTPMLIB_MainInit()\fB\fR was executed. Failure to delete the \s-1TPM\s0's state
files may put the \s-1TPM\s0 into failure mode.
.IP "\fBtpm_io_init\fR" 4
.IX Item "tpm_io_init"
This function is called to initialize the \s-1IO\s0 subsystem of the \s-1TPM.\s0
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation simply returns \fB\s-1TPM_SUCCESS\s0\fR.
.IP "\fBtpm_io_getlocality\fR" 4
.IX Item "tpm_io_getlocality"
This function is called when the \s-1TPM\s0 needs to determine the locality
under which a command is supposed to be executed. The implementing function
should return the number of the locality by writing it into the 
\&\fBlocalityModifier\fR pointer.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation returns 0 as the locality.
.IP "\fBtpm_io_getphysicalpresence\fR" 4
.IX Item "tpm_io_getphysicalpresence"
This function is called when the \s-1TPM\s0 needs to determine whether physical
presence has been asserted. The implementing function should write either
\&\fB\s-1TRUE\s0\fR or \fB\s-1FALSE\s0\fR into the physicalPresence pointer.
.Sp
Upon success this function should return \fB\s-1TPM_SUCCESS\s0\fR, a failure code
otherwise.
.Sp
The default implementation returns \fB\s-1FALSE\s0\fR for physical presence.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
Upon successful completion, \fB\fBTPMLIB_MainInit()\fB\fR returns \fB\s-1TPM_SUCCESS\s0\fR,
an error value otherwise.
.SH "ERRORS"
.IX Header "ERRORS"
.IP "\fB\s-1TPM_SUCCESS\s0\fR" 4
.IX Item "TPM_SUCCESS"
The function completed sucessfully.
.IP "\fB\s-1TPM_FAIL\s0\fR" 4
.IX Item "TPM_FAIL"
General failure.
.PP
For a complete list of \s-1TPM\s0 error codes please consult the include file
\&\fBlibtpms/tpm_error.h\fR
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 3
\& #include <libtpms/tpm_types.h>
\& #include <libtpms/tpm_library.h>
\& #include <libtpms/tpm_error.h>
\&
\& static TPM_MODIFIER_INDICATOR locality;
\&
\& static TPM_RESULT mytpm_io_init(void)
\& {
\&        return TPM_SUCCESS;
\& }
\&
\& static TPM_RESULT tpm_io_getlocality(TPM_MODIFIER_INDICATOR *locModif)
\& {
\&        *locModif = locality;
\&
\&        return TPM_SUCCESS:
\& }
\&
\& static TPM_RESULT mytpm_io_getphysicalpresence(TPM_BOOL *phyPres)
\& {
\&        *physicalPresence = FALSE;
\&
\&        return TPM_SUCCESS;
\& }
\&
\& int main(void) {
\&     TPM_RESULT res;
\&     unsigned char *respbuffer;
\&     uint32_t resp_size;
\&     uint32_t respbufsize;
\&     unsigned char *command;
\&     uint32_t command_size;
\&
\&     struct libtpms_callbacks cbs = {
\&         .sizeOfStruct               = sizeof(struct libtpms_callbacks),
\&         .tpm_nvram_init             = NULL,
\&         .tpm_nvram_loaddata         = NULL,
\&         .tpm_nvram_storedata        = NULL,
\&         .tpm_nvram_deletename       = NULL,
\&         .tpm_io_init                = mytpm_io_init,
\&         .tpm_io_getlocality         = mytpm_io_getlocality,
\&         .tpm_io_getphysicalpresence = mytpm_io_getphysicalpresence,
\&     };
\&
\&
\&     [...]
\&
\&     if (TPMLIB_RegisterCallbacks(cbs) != TPM_SUCCESS) {
\&         fprintf(stderr, "Could not register the callbacks.\en");
\&         return 1;
\&     }
\&
\&     if (TPMLIB_MainInit()) != TPM_SUCCESS) {
\&         fprintf(stderr, "Could not start the TPM.\en");
\&         return 1;
\&     }
\&
\&     [...]
\&     /* build TPM command */
\&     [...]
\&
\&     res = TPMLIB_Process(&respbuffer, &resp_size,
\&                          &respbufsize,
\&                          command, command_size);
\&     [...]
\&
\&     TPMLIB_Terminate();
\&
\&     return 0;
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBTPMLIB_Process\fR(3), \fBTPMLIB_MainInit\fR(3), \fBTPMLIB_Terminate\fR(3),
\&\fBTPMLIB_DecodeBlobs\fR(3)
